//ROS typedefs
#include "ros/ros.h"
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/PointCloud2.h>

/* BRICS_3D includes */
#include <brics_3d/algorithm/filtering/Octree.h>
#include <brics_3d/util/PCLTypecaster.h>

/* protected region user include files on begin */
/* protected region user include files end */

class OctreeFilter_config
{
public:
		double octreeCellSize;

};

class OctreeFilter_data
{
// autogenerated: don't touch this class
public:
//input data
    	sensor_msgs::PointCloud2 in_inputPointCloud;
  
	
//output data
    	sensor_msgs::PointCloud2 out_outputPointCloud;
 

};

class OctreeFilter_impl
{
	/* protected region user member variables on begin */
	brics_3d::Octree* filter;
	/* protected region user member variables end */

public:
    OctreeFilter_impl() 
    {
        /* protected region user constructor on begin */
    	filter = new brics_3d::Octree();
		/* protected region user constructor end */
    }
    void configure(OctreeFilter_config config) 
    {
        /* protected region user configure on begin */
		/* protected region user configure end */
    }
    void update(OctreeFilter_data &data, OctreeFilter_config config)
    {
        /* protected region user update on begin */

    	/* prepare input data */
    	std::string referenceFrameId;
    	referenceFrameId = data.in_inputPointCloud.header.frame_id;
    	pcl::PointCloud<pcl::PointXYZ>::Ptr inputPointCloutPcl(new pcl::PointCloud<pcl::PointXYZ>);
    	pcl::PointCloud<pcl::PointXYZ>::Ptr outputPointCloutPcl(new pcl::PointCloud<pcl::PointXYZ>);
    	pcl::fromROSMsg(data.in_inputPointCloud, *inputPointCloutPcl);

    	brics_3d::PointCloud3D inputPointCloud;
    	brics_3d::PointCloud3D outputPointCloud;

    	brics_3d::PCLTypecaster caster;
    	caster.convertToBRICS3DDataType(inputPointCloutPcl, &inputPointCloud);


    	/* do computation: subsampling based on an Octree filter */
    	ROS_INFO("Octree Filtering.");
    	filter->setVoxelSize(config.octreeCellSize);
    	ROS_INFO_STREAM("	using setVoxelSize = " << filter->getVoxelSize());
    	filter->filter(&inputPointCloud, &outputPointCloud);


    	/* prepare output data */
    	caster.convertToPCLDataType(outputPointCloutPcl, &outputPointCloud);
    	pcl::toROSMsg(*outputPointCloutPcl, data.out_outputPointCloud);
    	data.out_outputPointCloud.header.frame_id = referenceFrameId;

		/* protected region user update end */
    }

    
    /* protected region user additional functions on begin */
	/* protected region user additional functions end */
    
};
