//ROS typedefs
#include "ros/ros.h"
#include <pcl/PolygonMesh.h>
#include <sensor_msgs/PointCloud2.h>

/* protected region user include files on begin */
#include <brics_3d/core/PointCloud3D.h>
#include <brics_3d/core/TriangleMeshImplicit.h>
#include <brics_3d/util/PCLTypecaster.h>
#include <brics_3d/util/Timer.h>
#include <brics_3d/algorithm/meshGeneration/DelaunayTriangulationOSG.h>
/* protected region user include files end */

class MeshGenerator_config
{
public:

};

class MeshGenerator_data
{
// autogenerated: don't touch this class
public:
//input data
    	sensor_msgs::PointCloud2 in_inputPointCloud;
  
	
//output data
    	pcl::PolygonMesh out_mesh;
 

};

class MeshGenerator_impl
{
	/* protected region user member variables on begin */
	/* protected region user member variables end */

public:
    MeshGenerator_impl() 
    {
        /* protected region user constructor on begin */
		/* protected region user constructor end */
    }
    void configure(MeshGenerator_config config) 
    {
        /* protected region user configure on begin */
#ifdef ENABLE_OSG
    	ROS_INFO_STREAM("OSG is enabled.");
#else
    	ROS_WARN_STREAM("Implementation requires OSG to be available. Please recompile with installed OSG libraries and provide USE_OSG option to CMake.");
#endif
		/* protected region user configure end */
    }
    void update(MeshGenerator_data &data, MeshGenerator_config config)
    {
        /* protected region user update on begin */
    	/* Prepare data */
       	std::string referenceFrameId;
        referenceFrameId = data.in_inputPointCloud.header.frame_id;
        pcl::PointCloud<pcl::PointXYZ>::Ptr inputPointCloutPcl(new pcl::PointCloud<pcl::PointXYZ>);
        pcl::fromROSMsg(data.in_inputPointCloud, *inputPointCloutPcl);

        brics_3d::PointCloud3D inputPointCloud;
        brics_3d::PCLTypecaster caster;
        caster.convertToBRICS3DDataType(inputPointCloutPcl, &inputPointCloud);



#ifdef ENABLE_OSG
    	/* create mesh */
    	ROS_INFO_STREAM("Generating mesh.");

    	brics_3d::TriangleMeshImplicit* mesh = new brics_3d::TriangleMeshImplicit();
    	brics_3d::DelaunayTriangulationOSG* meshGenerator = new brics_3d::DelaunayTriangulationOSG();
    	meshGenerator->triangulate(&inputPointCloud, mesh);
    	ROS_INFO_STREAM("Number of generated triangles: " << mesh->getSize());
#else
    	return;
#endif

		/* Prepare output */


//		nVertices = meshImplicit->getNumberOfVertices();
//		nTriangles = meshImplicit->getSize(); //TODO: correct size
//		vertices = new osg::Vec3Array(nVertices);
//		indices = new osg::IntArray(nTriangles * 3);
//
//		for (int i=0; i < nVertices; ++i) {
//			tmpVertex = (*meshImplicit->getVertices())[i];
//			(*vertices)[i] = osg::Vec3(
//					//static_cast<value_type>(tmpVertex.getX()),
//					tmpVertex.getX(), // TODO: cast ?
//					tmpVertex.getY(),
//					tmpVertex.getZ());
//		}
//
//		int iOld = 0;
//		int iNew = 0;
//		for (int i=0; i < nTriangles; ++i) {
//			(*indices)[iNew++] = (*meshImplicit->getIndices())[iOld++];
//			(*indices)[iNew++] = (*meshImplicit->getIndices())[iOld++];
//			(*indices)[iNew++] = (*meshImplicit->getIndices())[iOld++];
//		}


    	data.out_mesh.cloud = data.in_inputPointCloud;
//		data.out_mesh.polygons.resize(1);
	    std::vector<int>* indices = mesh->getIndices();
	    data.out_mesh.polygons.clear();
	    data.out_mesh.polygons.resize(indices->size()/3);
	    unsigned int j = 0;
    	for (unsigned int i = 0; i < indices->size()/3; ++i) {
    		data.out_mesh.polygons[i].vertices.clear();
    		data.out_mesh.polygons[i].vertices.push_back((*indices)[j++]);
    		data.out_mesh.polygons[i].vertices.push_back((*indices)[j++]);
    		data.out_mesh.polygons[i].vertices.push_back((*indices)[j++]);
		}

		/* protected region user update end */
    }

    
    /* protected region user additional functions on begin */
	/* protected region user additional functions end */
    
};
