//ROS typedefs
#include "ros/ros.h"
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/PointCloud2.h>

/* protected region user include files on begin */
#include <brics_3d/core/HomogeneousMatrix44.h>
#include <brics_3d/algorithm/filtering/BoxROIExtractor.h>
#include <brics_3d/util/PCLTypecaster.h>

#include <tf/transform_listener.h>
#include "sensor_msgs/point_cloud_conversion.h"
/* protected region user include files end */

class ROIFilter_config
{
public:
		double min_x;
		double max_x;
		double min_y;
		double max_y;
		double min_z;
		double max_z;

};

class ROIFilter_data
{
// autogenerated: don't touch this class
public:
//input data
    	sensor_msgs::PointCloud2 in_inputPointCloud;
  
	
//output data
    	sensor_msgs::PointCloud2 out_outputPointCloud;
 

};

class ROIFilter_impl
{
	/* protected region user member variables on begin */
	brics_3d::BoxROIExtractor* filter;
	brics_3d::IHomogeneousMatrix44::IHomogeneousMatrix44Ptr center;

	tf::TransformListener tfListener;
	/* protected region user member variables end */

public:
    ROIFilter_impl() 
    {
        /* protected region user constructor on begin */
		/* protected region user constructor end */
    }
    void configure(ROIFilter_config config) 
    {
        /* protected region user configure on begin */
    	filter = new brics_3d::BoxROIExtractor();
    	center = brics_3d::HomogeneousMatrix44::IHomogeneousMatrix44Ptr(new brics_3d::HomogeneousMatrix44());
    	filter->setBoxOrigin(center);
		/* protected region user configure end */
    }
    void update(ROIFilter_data &data, ROIFilter_config config)
    {
        /* protected region user update on begin */
    	/* prepare input */

//		std::string sourceFrameId;
//		std::string targetFrameId;
		std::string from_frame = data.in_inputPointCloud.header.frame_id;
		std::string to_frame = "/base_link";
		ROS_DEBUG("from_frame: %s, to_frame %s", from_frame.c_str(), to_frame.c_str());
		sensor_msgs::PointCloud2 point_cloud_transformed;
		if (!transformPointCloud(tfListener, from_frame, to_frame, data.in_inputPointCloud, point_cloud_transformed)) {
			 ROS_INFO("pointCloud tf transform...failed");
			 data.out_outputPointCloud.header = data.in_inputPointCloud.header;
			 return;
		}



    	std::string referenceFrameId;
//    	referenceFrameId = data.in_inputPointCloud.header.frame_id;
    	referenceFrameId = to_frame;
    	pcl::PointCloud<pcl::PointXYZ>::Ptr inputPointCloutPcl(new pcl::PointCloud<pcl::PointXYZ>);
    	pcl::PointCloud<pcl::PointXYZ>::Ptr outputPointCloutPcl(new pcl::PointCloud<pcl::PointXYZ>);
//    	pcl::fromROSMsg(data.in_inputPointCloud, *inputPointCloutPcl);
    	pcl::fromROSMsg(point_cloud_transformed, *inputPointCloutPcl);


    	brics_3d::PointCloud3D inputPointCloud;
    	brics_3d::PointCloud3D outputPointCloud;

    	brics_3d::PCLTypecaster caster;
    	caster.convertToBRICS3DDataType(inputPointCloutPcl, &inputPointCloud);


    	/* do computation */
    	ROS_INFO_STREAM("ROIFiltering.");
//    	ROS_INFO_STREAM("\t with params: min_x = " << config.min_x << " max_x = " << config.max_x << " min_y = " << config.min_y << " max_y " << config.max_y << " min_z = " << config.min_z << " max_z = " << config.max_z);
    	filter->setSizeX(fabs(config.max_x-config.min_x)); // set new dimensions
    	filter->setSizeY(fabs(config.max_y-config.min_y));
    	filter->setSizeZ(fabs(config.max_z-config.min_z));
    	double* transformMatrix = center->setRawData(); // set new center
    	transformMatrix[12] = config.max_x - ((config.max_x-config.min_x)/2.0);
    	transformMatrix[13] = config.max_y - ((config.max_y-config.min_y)/2.0);
    	transformMatrix[14] = config.max_z - ((config.max_z-config.min_z)/2.0);
//    	ROS_INFO_STREAM("\t origin: " << *(filter->getBoxOrigin()));

    	filter->filter(&inputPointCloud, &outputPointCloud);

    	/* prepare output*/
    	caster.convertToPCLDataType(outputPointCloutPcl, &outputPointCloud);
    	pcl::toROSMsg(*outputPointCloutPcl, data.out_outputPointCloud);
    	data.out_outputPointCloud.header.frame_id = referenceFrameId;

		/* protected region user update end */
    }

    
    /* protected region user additional functions on begin */

    //Something hackish for now...
    bool transformPointCloud(tf::TransformListener &tfListener,
    		std::string &fromFrame, std::string &toFrame,
    		const sensor_msgs::PointCloud2 &srcPointCloud,
    		sensor_msgs::PointCloud2 &transformedPointCloud) {

    	//bool setup_tf = true;
    	bool success_tf = false;
    	tf::StampedTransform transform;

    	sensor_msgs::PointCloud pointCloudMsgConvert;
    	sensor_msgs::PointCloud pointCloudMsgTransformed;

    	sensor_msgs::convertPointCloud2ToPointCloud(srcPointCloud,pointCloudMsgConvert);

    		try {
    		tfListener.waitForTransform(fromFrame, toFrame, ros::Time::now(),
    					ros::Duration(1.0));
    		tfListener.transformPointCloud(std::string(toFrame),
    					pointCloudMsgConvert, pointCloudMsgTransformed);
    		success_tf = true;
    		} catch (tf::TransformException ex) {
    			success_tf = false;
    			return success_tf;
    		}

    	sensor_msgs::convertPointCloudToPointCloud2(pointCloudMsgTransformed, transformedPointCloud);

    	return success_tf;
    }

	/* protected region user additional functions end */
    
};
