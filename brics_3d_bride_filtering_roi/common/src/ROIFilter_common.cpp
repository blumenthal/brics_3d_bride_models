//ROS typedefs
#include "ros/ros.h"
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/PointCloud2.h>

/* protected region user include files on begin */
#include <brics_3d/core/HomogeneousMatrix44.h>
#include <brics_3d/algorithm/filtering/BoxROIExtractor.h>
/* protected region user include files end */

class ROIFilter_config
{
public:
		double min_x;
		double max_x;
		double min_y;
		double max_y;
		double min_z;
		double max_z;

};

class ROIFilter_data
{
// autogenerated: don't touch this class
public:
//input data
    	sensor_msgs::PointCloud2 in_inputPointCloud;
  
	
//output data
    	sensor_msgs::PointCloud2 out_outputPointCloud;
 

};

class ROIFilter_impl
{
	/* protected region user member variables on begin */
	brics_3d::BoxROIExtractor* roiFilter;
	brics_3d::IHomogeneousMatrix44* center;
	/* protected region user member variables end */

public:
    ROIFilter_impl() 
    {
        /* protected region user constructor on begin */
		/* protected region user constructor end */
    }
    void configure(ROIFilter_config config) 
    {
        /* protected region user configure on begin */
    	roiFilter = new brics_3d::BoxROIExtractor();
    	center = new brics_3d::HomogeneousMatrix44(); //
    	roiFilter->setBoxOrigin(center);
		/* protected region user configure end */
    }
    void update(ROIFilter_data &data, ROIFilter_config config)
    {
        /* protected region user update on begin */

    	/* prepare input */
    	std::string referenceFrameId;
    	referenceFrameId = data.in_inputPointCloud.header.frame_id;
    	pcl::PointCloud<pcl::PointXYZ>::Ptr inputPointCloutPcl(new pcl::PointCloud<pcl::PointXYZ>);
    	pcl::PointCloud<pcl::PointXYZ>::Ptr outputPointCloutPcl(new pcl::PointCloud<pcl::PointXYZ>);
    	pcl::fromROSMsg(data.in_inputPointCloud, *inputPointCloutPcl);

    	brics_3d::PointCloud3D inputPointCloud;
    	brics_3d::PointCloud3D outputPointCloud;

    	brics_3d::PCLTypecaster caster;
    	caster.convertToBRICS3DDataType(inputPointCloutPcl, &inputPointCloud);


    	filter->setSizeX(config.max_x-config.min_x); // set new dimensions
    	filter->setSizeY(config.max_y-config.min_y);
    	filter->setSizeZ(config.max_z-config.min_z);
    	double* transformMatrix = center->getSetRaw(); // set new center
    	transformMatrix[12] = (config.max_x-config.min_x)/2.0;
    	transformMatrix[13] = (config.max_y-config.min_y)/2.0;
    	transformMatrix[14] = (config.max_z-config.min_z)/2.0;

    	/* do computation */
    	ROS_INFO("ROIFiltering.");
    	filter->filter(&inputPointCloud, &outputPointCloud);

    	/* prepare output*/
    	caster.convertToPCLDataType(outputPointCloutPcl, &outputPointCloud);
    	pcl::toROSMsg(*outputPointCloutPcl, data.out_outputPointCloud);
    	data.out_outputPointCloud.header.frame_id = referenceFrameId;

		/* protected region user update end */
    }

    
    /* protected region user additional functions on begin */
	/* protected region user additional functions end */
    
};
