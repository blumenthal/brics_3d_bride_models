//ROS typedefs
#include "ros/ros.h"
#include <tf/tfMessage.h>
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/PointCloud2.h>

/* protected region user include files on begin */
#include <pcl/point_types.h>
#include <pcl/io/pcd_io.h>

/* BRICS_3D includes */
#include <brics_3d/core/HomogeneousMatrix44.h>
#include <brics_3d/algorithm/registration/IterativeClosestPoint.h>
#include <brics_3d/algorithm/registration/PointCorrespondenceKDTree.h>
#include <brics_3d/algorithm/registration/RigidTransformationEstimationSVD.h>
#include <brics_3d/util/PCLTypecaster.h>

#include <brics_3d_ros/SceneGraphTypeCasts.h>

typedef pcl::PointXYZ PointType;
/* protected region user include files end */

class Registrator_config
{
public:

};

class Registrator_data
{
// autogenerated: don't touch this class
public:
//input data
    	sensor_msgs::PointCloud2 in_dataPointCloud;
    	sensor_msgs::PointCloud2 in_modelPointCloud;
  
	
//output data
    	tf::tfMessage out_transform;
 

};

class Registrator_impl
{
	/* protected region user member variables on begin */
	brics_3d::IRegistration* registrator;
	/* protected region user member variables end */

public:
    Registrator_impl() 
    {
        /* protected region user constructor on begin */
		/* protected region user constructor end */
    }
    void configure(Registrator_config config) 
    {
        /* protected region user configure on begin */
    	registrator = new brics_3d::IterativeClosestPoint(new brics_3d::PointCorrespondenceKDTree(), new brics_3d::RigidTransformationEstimationSVD());
		/* protected region user configure end */
    }
    void update(Registrator_data &data, Registrator_config config)
    {
        /* protected region user update on begin */
    	if(data.in_dataPointCloud.width == 0 || data.in_modelPointCloud.width == 0) {
    		ROS_WARN_STREAM("Empty input point clouds. Skipping.");
    		return;
    	}

    	/* data conversions */
    	pcl::PointCloud<PointType>::Ptr dataPointCloutPcl(new pcl::PointCloud<PointType>);
    	pcl::PointCloud<PointType>::Ptr modelPointCloutPcl(new pcl::PointCloud<PointType>);
    	pcl::fromROSMsg(data.in_dataPointCloud, *dataPointCloutPcl);
    	pcl::fromROSMsg(data.in_modelPointCloud, *modelPointCloutPcl);

    	brics_3d::PointCloud3D dataPointCloud;
    	brics_3d::PointCloud3D modelPointCloud;

    	brics_3d::PCLTypecaster caster;
    	caster.convertToBRICS3DDataType(dataPointCloutPcl, &dataPointCloud);
    	caster.convertToBRICS3DDataType(modelPointCloutPcl, &modelPointCloud);
    	brics_3d::IHomogeneousMatrix44::IHomogeneousMatrix44Ptr resultTransform(new brics_3d::HomogeneousMatrix44());

    	/* The actual computation: registration of two point clouds */
    	ROS_INFO("Registering.");
    	registrator->match(&modelPointCloud, &dataPointCloud, resultTransform.get());
    	ROS_INFO_STREAM("resulting transform = " << std::endl << *resultTransform);

    	/* Some gymnastics to publish a TF. In BRIDE code we cannot use the tf brodcaster... */
    	tf::Transform tfTransform;
    	tf::StampedTransform tfStampedTransform;
    	geometry_msgs::TransformStamped tfGeometryMsg;
    	brics_3d::rsg::SceneGraphTypeCasts::convertHomogeniousMatrixToTfTransform(resultTransform, tfTransform);
    	tfStampedTransform.setData(tfTransform);
    	tf::transformStampedTFToMsg(tfStampedTransform, tfGeometryMsg);

    	tf::tfMessage message;
    	message.transforms.push_back(tfGeometryMsg);
    	data.out_transform = message;
		/* protected region user update end */
    }

    
    /* protected region user additional functions on begin */
	/* protected region user additional functions end */
    
};
